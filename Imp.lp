// Imp: Simple Imperative Programs

// This file is the translation of the file Imp.v (Tome 1 - Software Foundations)
require open amelie.lambdapi_examples.Notation
require open amelie.lambdapi_examples.Bool

set builtin "Prop"     â‰” Prop

constant symbol nat : Set // Natural number
inductive Nat : TYPE â‰”
 | z    : Nat
 | succ : Nat â†’ Nat
rule Nat â†ª Ï„ nat

set builtin "0"  â‰” z
set builtin "+1" â‰” succ
///////////////////////////////////////////
// Arithmetic and Boolean Expressions
///////////////////////////////////////////

inductive aexp : TYPE â‰”
 | ANum   : Î n:Nat, aexp
 | APlus  : Î a1:aexp, Î a2 : aexp, aexp
 | AMinus : Î a1:aexp, Î a2 : aexp, aexp
 | AMult  : Î a1:aexp, Î a2 : aexp, aexp

inductive bexp : TYPE â‰”
 | BTrue  : bexp
 | BFalse : bexp
 | BEq    : Î a1:aexp, Î a2 : aexp, bexp
 | BLe    : Î a1:aexp, Î a2 : aexp, bexp
 | BNot   : Î b:bexp, bexp
 | BAnd   : Î b1:bexp, Î b2 : bexp, bexp

///////////////////////////////////////////
// Evaluation
///////////////////////////////////////////

symbol plus : Nat â†’ Nat â†’ Nat
set infix left 6 "+" â‰” plus
rule       z + $y â†ª $y
with succ $x + $y â†ª succ ($x + $y)

symbol mult : Nat â†’ Nat â†’ Nat
set infix left 7 "Ã—" â‰” mult
rule       z Ã— _  â†ª z
with succ $x Ã— $y â†ª $y + $x Ã— $y

symbol sub : Nat â†’ Nat â†’ Nat
set infix left 7 "-" â‰” sub
rule     z  - z        â†ª z
with succ _ - z        â†ª z
with     z - succ _    â†ª z
with succ $x - succ $y â†ª $x - $y

symbol aeval : aexp â†’ Nat
rule aeval (ANum $n) â†ª $n
with aeval (APlus  $a1 $a2) â†ª (aeval $a1) + (aeval $a2)
with aeval (AMinus $a1 $a2) â†ª (aeval $a1) - (aeval $a2)
with aeval (AMult  $a1 $a2) â†ª (aeval $a1) Ã— (aeval $a2)

theorem ex_test_aeval1 : Ï€ (aeval (APlus (ANum 2) (ANum 2)) = 4)
proof
 reflexivity
qed


//symbol eqb : ğ”¹â†’ ğ”¹â†’ ğ”¹
// rule eqb true  $b â†ª $b
// with eqb false $b â†ª not $b

symbol eqb : Nat â†’ Nat â†’ ğ”¹
rule eqb    z         z      â†ª true
with eqb (succ $x) (succ $y) â†ª eqb $x $y
with eqb    z      (succ  _) â†ª false
with eqb (succ  _)    z      â†ª false

symbol leb : Nat â†’ Nat â†’ ğ”¹
rule leb     z         z         â†ª true
with leb    z      (succ _)      â†ª true
with leb (succ $m) (succ $n) â†ª leb $m $n
with leb (succ _)      z     â†ª false

symbol beval : bexp â†’ ğ”¹
rule beval BTrue          â†ª true
with beval BFalse         â†ª false
with beval (BEq $a1 $a2)  â†ª eqb (aeval $a1) (aeval $a2)
with beval (BLe $a1 $a2)  â†ª leb (aeval $a1) (aeval $a2)
with beval (BNot $b)      â†ª neg (beval $b)
with beval (BAnd $b1 $b2) â†ª andb (beval $b1) (beval $b2)

///////////////////////////////////////////
// Optimization
///////////////////////////////////////////

symbol opti_0plus : aexp â†’ aexp
rule opti_0plus (ANum $n) â†ª (ANum $n)
with opti_0plus (APlus (ANum z) $e) â†ª opti_0plus $e
with opti_0plus (APlus  $e1 $e2)    â†ª APlus  (opti_0plus $e1) (opti_0plus $e2)
with opti_0plus (AMinus $e1 $e2)    â†ª AMinus (opti_0plus $e1) (opti_0plus $e2)
with opti_0plus (AMult  $e1 $e2)    â†ª AMult  (opti_0plus $e1) (opti_0plus $e2)

// theorem test_opti_0plus :
//   Ï€ (opti_0plus (APlus (ANum 2)
//                        (APlus (ANum 0)
//                               (APlus (ANum 0) (ANum 1))))
//                 = APlus (ANum 2) (ANum 1))
// proof
// qed

theorem optimize_0plus_sound: Î  a, Ï€ (aeval (opti_0plus a) = aeval a)
proof
  assume a
  refine ind_aexp (Î»p, aeval (opti_0plus p) = aeval p) _ _ _ _ a
  // 0. Î x: Ï„ nat, Ï€ (aeval (opti_0plus (ANum x)) = aeval (ANum x))
  assume x reflexivity
  // 1. Î x: aexp, Ï€ (aeval (opti_0plus x) = aeval x) â†’
  //    Î x0: aexp, Ï€ (aeval (opti_0plus x0) = aeval x0) â†’
  //      Ï€ (aeval (opti_0plus (APlus x x0)) = aeval (APlus x x0))
  assume x Hx x0 Hx0
  refine ind_aexp (Î»p, aeval (opti_0plus (APlus p x0)) = aeval (APlus p x0)) _ _ _ _ x
     simpl assume x1
     refine ind_Nat (Î»p, (p + aeval (opti_0plus x0)) = (p + aeval x0)) _ _ x1
         apply Hx0
         assume x2 Hx2 simpl rewrite Hx2 reflexivity
     simpl assume x1 Hx1 x2 Hx2 rewrite Hx0
 simpl
  // 2. Î x: aexp, Ï€ (aeval (opti_0plus x) = aeval x) â†’
  //    Î x0: aexp, Ï€ (aeval (opti_0plus x0) = aeval x0) â†’
  //        Ï€ (aeval (opti_0plus (AMinus x x0)) = aeval (AMinus x x0))

  // 3. Î x: aexp, Ï€ (aeval (opti_0plus x) = aeval x) â†’
  //    Î x0: aexp, Ï€ (aeval (opti_0plus x0) = aeval x0) â†’
  //        Ï€ (aeval (opti_0plus (AMult x x0)) = aeval (AMult x x0))
qed
