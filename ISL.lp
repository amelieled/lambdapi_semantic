require open amelie.lambdapi_examples.Notation
//require open amelie.lambdapi_examples.Nat
// require open amelie.lambdapi_examples.Bool
// require open amelie.lambdapi_examples.Operations
require open amelie.lambdapi_examples.Constructive_logic

constant symbol Z : Set
set declared "â„¤"
definition â„¤ â‰” Ï„ Z

symbol plus_int : â„¤ â†’ â„¤ â†’ â„¤
set infix left 6 "+" â‰” plus_int

symbol mult_int : â„¤ â†’ â„¤ â†’ â„¤
set infix left 7 "Ã—" â‰” mult_int

symbol minus_int : â„¤ â†’ â„¤ â†’ â„¤
symbol opp_int   : â„¤ â†’ â„¤
// set infix left 6 "-" â‰” minus_int
// set infix 6 "-" â‰” opp_int

// The previous type defines the variable set
// We assume the egality is decidable on Vvar
constant symbol Vvar : Set
set declared "ğ•var"
definition ğ•var â‰” Ï„ Vvar

constant symbol EA : Set
set declared "ğ”¼ğ”¸"
definition ğ”¼ğ”¸ â‰” Ï„ (EA)
constant symbol ent   : â„¤ â†’ ğ”¼ğ”¸                //  /!\ Z !
constant symbol var   : ğ•var â†’ ğ”¼ğ”¸
constant symbol plus  : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
constant symbol fois  : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
constant symbol opp   : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
symbol EA_ind (p : ğ”¼ğ”¸ â†’ Prop) :
(Î n, Ï€ (p (ent n))) â†’
(Î x, Ï€ (p (var x))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (plus a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (fois a1 a2))) â†’
(Î a, Ï€ (p a) â†’ Ï€ (p (opp a))) â†’
Î x, Ï€ (p x)

// The type of variable valuation
constant symbol S : Set
set declared "Î£"
definition Î£ â‰” ğ•var â†’ â„¤

symbol eval_EA : ğ”¼ğ”¸ â†’ Î£ â†’ â„¤â†’ Prop
constant symbol eval_var s x :
  Ï€ (eval_EA (var x) s (s x))
constant symbol eval_nb  s n :
  Ï€ (eval_EA (ent n) s n)
constant symbol eval_plus s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (plus a1 a2) s (n1 + n2))
constant symbol eval_fois s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (fois a1 a2) s (n1 Ã— n2))
constant symbol eval_opp s a n :
  Ï€ (eval_EA a s n) â†’
  Ï€ (eval_EA (opp a) s (opp_int n))

symbol ent_inv s n v :
  Ï€ (eval_EA (ent n) s v) â†’ Ï€ (n = v)
symbol var_inv s x v :
  Ï€ (eval_EA (var x) s v) â†’ Ï€ (s x = v)
symbol plus_inv s a1 a2 v:
  Ï€ (eval_EA (plus a1 a2) s v) â†’
  Ï€ (âˆƒ(Î»n1, âˆƒ(Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 + n2) = v)))
symbol fois_inv s a1 a2 v:
  Ï€ (eval_EA (fois a1 a2) s v) â†’
  Ï€ (âˆƒ(Î»n1, âˆƒ(Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 Ã— n2) = v)))
symbol opp_inv s a v :
  Ï€ (eval_EA (opp a) s v) â†’
  Ï€ (âˆƒ(Î»n, eval_EA a s n âˆ§ (opp_int n) = v))

symbol arr: Set â†’ Set â†’ Set
set infix right 6 "â­" â‰” arr
rule Ï„($x â­ $y) â†ª Ï„ $x â†’ Ï„ $y

theorem exp_deterministe e s v1 v2 : Ï€ (eval_EA e s v1 âŠƒ eval_EA e s v2 âŠƒ v1 = v2)
proof
  refine EA_ind _ _ _ _ _ _
  // Case "ent"
  assume n s v1 v2 Hv1 Hv2
  apply imp_elim (n = v1)
     // 0. Ï€ (n = v1) â†’ Ï€ (v1 = v2)
     assume Heqvv1 rewrite - Heqvv1 apply ent_inv s refine Hv2
     // 1. Ï€ (n = v1)
     apply ent_inv s refine Hv1
  // Case "var"
  assume x s v1 v2 Hv1 Hv2
  apply imp_elim (s x = v1)
     // 0. Ï€ (s x = v1) â†’ Ï€ (v1 = v2)
     assume Heqxv1 rewrite - Heqxv1 apply var_inv s refine Hv2
     // 1. Ï€ (s x = v1)
     apply var_inv s refine Hv1
  // Case "plus"
  assume a1 Ha1 a2 Ha2 s v1 v2 Hv1 Hv2
  apply imp_elim (âˆƒ (Î»n1, âˆƒ(Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 + n2) = v1)))
  assume Heq
  apply ex_elim (Î»n1, âˆƒ (Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 + n2) = v1)) _
  apply Heq assume n1 H2
  apply ex_elim (Î»n2, (eval_EA a1 s n1 âˆ§ (eval_EA a2 s n2 âˆ§ ((n1 + n2) = v1))))
  apply H2 assume n2 H3

  apply imp_elim (âˆƒ (Î»n3, âˆƒ(Î»n4, eval_EA a1 s n3 âˆ§ eval_EA a2 s n4 âˆ§ (n3 + n4) = v2)))
  assume Heq2
  apply ex_elim (Î»n3, âˆƒ (Î»n4, eval_EA a1 s n3 âˆ§ eval_EA a2 s n4 âˆ§ (n3 + n4) = v2)) _
  apply Heq2 assume n3 H22
  apply ex_elim (Î»n4, (eval_EA a1 s n3 âˆ§ (eval_EA a2 s n4 âˆ§ ((n3 + n4) = v2))))
  apply H22 assume n4 H32

  apply imp_elim ((n1 + n2) = v1) assume Hplus rewrite - Hplus
  apply imp_elim ((n3 + n4) = v2) assume Hplus2 rewrite - Hplus2
  apply imp_elim (n1 = n3) assume Hn1n3 rewrite Hn1n3
  apply imp_elim (n2 = n4) assume Hn2n4 rewrite Hn2n4 reflexivity
  apply Ha2 s n2 n4
  apply conj_elim_left _ ((n1 + n2) = v1)
  apply conj_elim_right (eval_EA a1 s n1) apply H3

  apply conj_elim_left _ ((n3 + n4) = v2)
  apply conj_elim_right (eval_EA a1 s n3) apply H32

  apply Ha1 s n1 n3
  apply conj_elim_left _ (eval_EA a2 s n2 âˆ§ ((n1 + n2) = v1)) apply H3

  apply conj_elim_left _ (eval_EA a2 s n4 âˆ§ ((n3 + n4) = v2)) apply H32

  apply conj_elim_right (eval_EA a2 s n4)
  apply conj_elim_right (eval_EA a1 s n3) apply H32

  apply conj_elim_right (eval_EA a2 s n2)
  apply conj_elim_right (eval_EA a1 s n1) apply H3

  apply plus_inv s a1 a2 apply Hv2
  apply plus_inv s a1 a2 apply Hv1

   // Case "fois"

  assume a1 Ha1 a2 Ha2 s v1 v2 Hv1 Hv2
  apply imp_elim (âˆƒ (Î»n1, âˆƒ(Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 Ã— n2) = v1)))
  assume Heq
  apply ex_elim (Î»n1, âˆƒ (Î»n2, eval_EA a1 s n1 âˆ§ eval_EA a2 s n2 âˆ§ (n1 Ã— n2) = v1)) _
  apply Heq assume n1 H2
  apply ex_elim (Î»n2, (eval_EA a1 s n1 âˆ§ (eval_EA a2 s n2 âˆ§ ((n1 Ã— n2) = v1))))
  apply H2 assume n2 H3

  apply imp_elim (âˆƒ (Î»n3, âˆƒ(Î»n4, eval_EA a1 s n3 âˆ§ eval_EA a2 s n4 âˆ§ (n3 Ã— n4) = v2)))
  assume Heq2
  apply ex_elim (Î»n3, âˆƒ (Î»n4, eval_EA a1 s n3 âˆ§ eval_EA a2 s n4 âˆ§ (n3 Ã— n4) = v2)) _
  apply Heq2 assume n3 H22
  apply ex_elim (Î»n4, (eval_EA a1 s n3 âˆ§ (eval_EA a2 s n4 âˆ§ ((n3 Ã— n4) = v2))))
  apply H22 assume n4 H32

  apply imp_elim ((n1 Ã— n2) = v1) assume Hplus rewrite - Hplus
  apply imp_elim ((n3 Ã— n4) = v2) assume Hplus2 rewrite - Hplus2
  apply imp_elim (n1 = n3) assume Hn1n3 rewrite Hn1n3
  apply imp_elim (n2 = n4) assume Hn2n4 rewrite Hn2n4 reflexivity
  apply Ha2 s n2 n4
  apply conj_elim_left _ ((n1 Ã— n2) = v1)
  apply conj_elim_right (eval_EA a1 s n1) apply H3

  apply conj_elim_left _ ((n3 Ã— n4) = v2)
  apply conj_elim_right (eval_EA a1 s n3) apply H32

  apply Ha1 s n1 n3
  apply conj_elim_left _ (eval_EA a2 s n2 âˆ§ ((n1 Ã— n2) = v1)) apply H3

  apply conj_elim_left _ (eval_EA a2 s n4 âˆ§ ((n3 Ã— n4) = v2)) apply H32

  apply conj_elim_right (eval_EA a2 s n4)
  apply conj_elim_right (eval_EA a1 s n3) apply H32

  apply conj_elim_right (eval_EA a2 s n2)
  apply conj_elim_right (eval_EA a1 s n1) apply H3

  apply fois_inv s a1 a2 apply Hv2
  apply fois_inv s a1 a2 apply Hv1

  // Case "opp"
  assume a Ha s v1 v2 Hv1 Hv2
  apply imp_elim (âˆƒ (Î»n, eval_EA a s n âˆ§ (opp_int n) = v1))
  assume Heq
  apply ex_elim (Î»n, eval_EA a s n âˆ§ (opp_int n) = v1) _
  apply Heq assume n1 H2

  apply imp_elim (âˆƒ (Î»n, eval_EA a s n âˆ§ (opp_int n) = v2))
  assume Heq2
  apply ex_elim (Î»n, eval_EA a s n âˆ§ (opp_int n) = v2) _
  apply Heq2 assume n2 H22

  apply imp_elim ((opp_int n1) = v1) assume Hplus rewrite - Hplus
  apply imp_elim ((opp_int n2) = v2) assume Hplus2 rewrite - Hplus2
  apply imp_elim (n1 = n2) assume Hn1n2 rewrite Hn1n2 reflexivity
  apply Ha s n1 n2
  apply conj_elim_left _ ((opp_int n1) = v1) apply H2
  apply conj_elim_left _ ((opp_int n2) = v2) apply H22
  apply conj_elim_right (eval_EA a s n2) apply H22
  apply conj_elim_right (eval_EA a s n1) apply H2

  apply opp_inv s a apply Hv2
  apply opp_inv s a apply Hv1

qed
