// SEMANTIQUE OPERATIONNELLE

require open amelie.lambdapi_examples.Notation
require open amelie.lambdapi_examples.Nat
require open amelie.lambdapi_examples.Bool
require open amelie.lambdapi_examples.Operations

symbol if {a} : ğ”¹ â†’ a â†’ a â†’ a
rule if true  $t _  â†ª $t
with if false _  $f â†ª $f

symbol substraction : â„• â†’ â„• â†’ â„•
set infix left 6 "-" â‰” substraction
rule       0 - $y â†ª 0
with      $y - 0  â†ª 0
with succ $x - succ $y â†ª $x - $y

symbol division : â„• â†’ â„• â†’ â„•
set infix left 6 "Ã·" â‰” division
rule       0 Ã· _ â†ª 0
//with succ $x + $y â†ª succ ($x + $y)

// EXPRESSIONS ARITHMETIQUES

// OCaml
// type â€™a exp_arith =
//     Ent of int | Var of â€™a
//   | Plus of â€™a exp_arith*â€™a exp_arith
//   | Moins of â€™a exp_arith*â€™a exp_arith
//   | Fois of â€™a exp_arith*â€™a exp_arith
//   | Div of â€™a exp_arith*â€™a exp_arith;;
constant symbol EA : Set â†’ Set
set declared "ğ”¼ğ”¸"
definition ğ”¼ğ”¸a â‰” Ï„ (EA a)
constant symbol ent {a} : â„• â†’ ğ”¼ğ”¸a
constant symbol var {a} : Ï„ a â†’ ğ”¼ğ”¸a
constant symbol plus {a} : ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a
constant symbol moins {a} : ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a
constant symbol fois {a} : ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a
constant symbol div {a} : ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a â†’ ğ”¼ğ”¸a
symbol EA_ind {a} (p : ğ”¼ğ”¸a â†’ Prop) :
(Î n, Ï€ (p (ent n))) â†’
(Î x, Ï€ (p (var x))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (plus a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (moins a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (fois a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (div a1 a2))) â†’
Î x, Ï€ (p x)

// INTERPRETATION des EXPR. ARITH

//Inductive values : Set := Val : Z -> values | Erreur : values.
constant symbol values : Set
set declared "ğ•"
definition ğ• â‰” Ï„ values
constant symbol val : â„• â†’ ğ•
constant symbol erreur : ğ•

// INTERPRETATION des SYMBOLES

symbol i_plus : ğ•â†’ ğ•â†’ ğ•
rule i_plus (val $n1) (val $n2) â†ª val ($n1 + $n2)
with i_plus erreur _ â†ª erreur
with i_plus _ erreur â†ª erreur

symbol i_moins: ğ•â†’ ğ•â†’ ğ•
rule i_moins (val $n1) (val $n2) â†ª val ($n1 - $n2)
with i_moins erreur _ â†ª erreur
with i_moins _ erreur â†ª erreur

symbol i_fois : ğ•â†’ ğ•â†’ ğ•
rule i_fois (val $n1) (val $n2) â†ª val ($n1 Ã— $n2)
with i_fois erreur _ â†ª erreur
with i_fois _ erreur â†ª erreur

symbol i_div : ğ•â†’ ğ•â†’ ğ•
rule i_div (val $n1) (val $n2) â†ª
    if (eqb_nat $n2 0) erreur (val ($n1 Ã· $n2))
with i_div erreur _ â†ª erreur
with i_div _ erreur â†ª erreur

// EVALUATION des EXPR. ARITH

// Definition Sigma : Set := V -> Z.
constant symbol sigma : Set
//set declared "Î£i"
//definition Î£i â‰” ğ•â†’ â„•
set declared "Î£"
definition Î£ {a} â‰” Ï„ a â†’ â„•

//Fixpoint eval_EA_fct (s:Sigma)(a:EA){struct a} : values :=
// match a with
// (nb n) => (Val n)
// | (var x) => (Val (s x))
// | ...
// | (dv a1 a2) => match ((eval_EA_fct s a1),(eval_EA_fct s a2)) with
// ((Val n1),(Val n2)) => (match n2 with
// â€˜0â€˜ => Erreur
// | _ => (Val (Zdiv n1 n2))
// end)
// | (Erreur,_) => Erreur
// | ((Val _), Erreur) => Erreur
// end)
// end.
symbol eval_EA_fct {a} : Î£ {a} â†’ ğ”¼ğ”¸a â†’ ğ•
rule eval_EA_fct _ (ent $n) â†ª val $n
with eval_EA_fct $s (var $x) â†ª val ($s $x)
with eval_EA_fct $s (plus $a1 $a2)  â†ª
     i_plus  (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (moins $a1 $a2) â†ª
     i_moins (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (fois $a1 $a2)      â†ª
     i_fois  (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (div$a1 $a2)    â†ª
     i_div   (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)

compute eval_EA_fct _ (plus (ent 3) (ent 4))

// SEMANTIQUE OPERATIONNELLE D'EVALUATION A GRANDS PAS

// Inductive eval_EA : EA -> Sigma -> values -> Prop :=
// | eval_var : forall (s:Sigma)(v:V),(eval_EA (var v) s (s v))
// | eval_nb : forall (s:Sigma)(n : Z), (eval_EA (nb n) s (Val n))
// | eval_pls : forall (s:Sigma)(a1 a2:EA)(n1 n2:values),
// (eval_EA a1 s n1) -> (eval_EA a2 s n2) ->
// (eval_EA (pls a1 a2) s (ZplusErr n1 n2))
// ...
// | eval_dv : forall (s:Sigma)(a1 a2:EA)(n1 n2: values),
// (eval_EA s a1 n1) -> (eval_EA s a2 n2) ->
// (eval_EA s (dv a1 a2) (ZdivErr n1 n2)).
// avec Definition ZplusErr (v1 v2 : values) : values := match (v1, v2) with
// Val x1, Val x2 => Val (x1 + x2)
// | Erreur, _ => Erreur
// | _, Erreur => Erreur
// end.
symbol eval_EA {a} : ğ”¼ğ”¸a â†’ Î£ {a} â†’ ğ•â†’ Prop
constant symbol eval_var {a} (s:Î£ {a}) x :
  Ï€ (eval_EA (var x) s (val (s x)))
constant symbol eval_nb  {a} (s:Î£ {a}) n :
  Ï€ (eval_EA (ent n) s (val n))
constant symbol eval_plus {a} (s:Î£ {a}) a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (plus a1 a2) s (i_plus n1 n2))
// constant symbol eval {a} (s:Î£ {a}) a1 a2 n1 n2 :
//  Ï€ (eval_EA s (plus a1 a2) (i_plus  (eval_EA s a1) (eval_EA s a2)))
constant symbol eval_moins {a} (s:Î£ {a}) a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (moins a1 a2) s (i_moins n1 n2))
constant symbol eval_fois {a} (s:Î£ {a}) a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (fois a1 a2) s (i_fois n1 n2))
constant symbol eval_div {a} (s:Î£ {a}) a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (div a1 a2) s (i_div n1 n2))

//compute eval_EA (plus (ent 3) (ent 4)) _ (val (ent 7))
theorem eval_example (s:Î£ {nat}) :
Ï€ (eval_EA {nat} (fois {nat} (ent {nat} 2) (ent {nat} 3)) s (val 6))
//Ï€ (eval_EA (ent 2) s (val (ent 5)))
proof
  assume s
  refine eval_fois s _ _ _ _
qed

theorem det_eval_EA {t} a (s:Î£ {t}) v1 v2 :
Ï€ (eval_EA a s v1) â†’ Ï€ (eval_EA a s v2) â†’ Ï€ (v1 = v2)
proof
  //assume t a s v1 v2
  refine EA_ind _ _ _ _ _ _ //t a s v1 v2
qed
