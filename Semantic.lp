// SEMANTIQUE OPERATIONNELLE

require open amelie.lambdapi_examples.Notation
require open amelie.lambdapi_examples.Nat
require open amelie.lambdapi_examples.Bool
require open amelie.lambdapi_examples.Operations
require open amelie.lambdapi_examples.Constructive_logic

symbol if {a} : ğ”¹ â†’ a â†’ a â†’ a
rule if true  $t _  â†ª $t
with if false _  $f â†ª $f

symbol substraction : â„• â†’ â„• â†’ â„•
set infix left 6 "-" â‰” substraction
rule       0 - $y â†ª 0
with      $y - 0  â†ª 0
with succ $x - succ $y â†ª $x - $y

symbol division : â„• â†’ â„• â†’ â„•
set infix left 6 "Ã·" â‰” division
rule       0 Ã· _ â†ª 0
//with succ $x + $y â†ª succ ($x + $y)

// EXPRESSIONS ARITHMETIQUES

// Coq
// Parameter V : Set.
// Parameter eq_dec_V : forall (v1 v2:V),{v1=v2}+{~v1=v2}.
// Inductive EA : Set :=
//   nb : Z -> EA | var : V -> EA | pls : EA -> EA -> EA
// | mns : EA -> EA -> EA | mlt : EA -> EA -> EA | dv : EA -> EA -> EA.
constant symbol Vvar : Set
set declared "ğ•var"
definition ğ•var â‰” Ï„ Vvar

constant symbol EA : Set
set declared "ğ”¼ğ”¸"
definition ğ”¼ğ”¸ â‰” Ï„ (EA)
constant symbol ent   : â„• â†’ ğ”¼ğ”¸                //  /!\ Z !
constant symbol var   : ğ•var â†’ ğ”¼ğ”¸
constant symbol plus  : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
constant symbol moins : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
constant symbol fois  : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
constant symbol div   : ğ”¼ğ”¸ â†’ ğ”¼ğ”¸ â†’ ğ”¼ğ”¸
symbol EA_ind (p : ğ”¼ğ”¸ â†’ Prop) :
(Î n, Ï€ (p (ent n))) â†’
(Î x, Ï€ (p (var x))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (plus a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (moins a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (fois a1 a2))) â†’
(Î a1, Ï€ (p a1) â†’ Î a2, Ï€ (p a2) â†’ Ï€ (p (div a1 a2))) â†’
Î x, Ï€ (p x)

// INTERPRETATION des EXPR. ARITH

//Inductive values : Set := Val : Z -> values | Erreur : values.
constant symbol values : Set
set declared "ğ•"
definition ğ• â‰” Ï„ values
constant symbol val : â„• â†’ ğ•               //  /!\ Z !
constant symbol erreur : ğ•

// INTERPRETATION des SYMBOLES

symbol i_plus : ğ•â†’ ğ•â†’ ğ•
rule i_plus (val $n1) (val $n2) â†ª val ($n1 + $n2)
with i_plus erreur _ â†ª erreur
with i_plus _ erreur â†ª erreur

symbol i_moins: ğ•â†’ ğ•â†’ ğ•
rule i_moins (val $n1) (val $n2) â†ª val ($n1 - $n2)
with i_moins erreur _ â†ª erreur
with i_moins _ erreur â†ª erreur

symbol i_fois : ğ•â†’ ğ•â†’ ğ•
rule i_fois (val $n1) (val $n2) â†ª val ($n1 Ã— $n2)
with i_fois erreur _ â†ª erreur
with i_fois _ erreur â†ª erreur

symbol i_div : ğ•â†’ ğ•â†’ ğ•
rule i_div (val $n1) (val $n2) â†ª
    if (eqb_nat $n2 0) erreur (val ($n1 Ã· $n2))
with i_div erreur _ â†ª erreur
with i_div _ erreur â†ª erreur

// EVALUATION des EXPR. ARITH

// Definition Sigma : Set := V -> Z.
constant symbol sigma : Set
//set declared "Î£i"
//definition Î£i â‰” ğ•â†’ â„•

set declared "Î£"
//definition Î£ {a} â‰” Ï„ a â†’ â„•
definition Î£ â‰” ğ•var â†’ â„•

//Fixpoint eval_EA_fct (s:Sigma)(a:EA){struct a} : values :=
// match a with
// (nb n) => (Val n)
// | (var x) => (Val (s x))
// | ...
// | (dv a1 a2) => match ((eval_EA_fct s a1),(eval_EA_fct s a2)) with
// ((Val n1),(Val n2)) => (match n2 with
// â€˜0â€˜ => Erreur
// | _ => (Val (Zdiv n1 n2))
// end)
// | (Erreur,_) => Erreur
// | ((Val _), Erreur) => Erreur
// end)
// end.
symbol eval_EA_fct : Î£ â†’ ğ”¼ğ”¸ â†’ ğ•
rule eval_EA_fct _  (ent $n) â†ª val $n
with eval_EA_fct $s (var $x) â†ª val ($s $x)
with eval_EA_fct $s (plus $a1 $a2)  â†ª
     i_plus  (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (moins $a1 $a2) â†ª
     i_moins (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (fois $a1 $a2)  â†ª
     i_fois  (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)
with eval_EA_fct $s (div$a1 $a2)    â†ª
     i_div   (eval_EA_fct $s $a1) (eval_EA_fct $s $a2)

compute eval_EA_fct _ (plus (ent 3) (ent 4))

// SEMANTIQUE OPERATIONNELLE D'EVALUATION A GRANDS PAS

// Inductive eval_EA : EA -> Sigma -> values -> Prop :=
// | eval_var : forall (s:Sigma)(v:V),(eval_EA (var v) s (s v))
// | eval_nb : forall (s:Sigma)(n : Z), (eval_EA (nb n) s (Val n))
// | eval_pls : forall (s:Sigma)(a1 a2:EA)(n1 n2:values),
// (eval_EA a1 s n1) -> (eval_EA a2 s n2) ->
// (eval_EA (pls a1 a2) s (ZplusErr n1 n2))
// ...
// | eval_dv : forall (s:Sigma)(a1 a2:EA)(n1 n2: values),
// (eval_EA s a1 n1) -> (eval_EA s a2 n2) ->
// (eval_EA s (dv a1 a2) (ZdivErr n1 n2)).
// avec Definition ZplusErr (v1 v2 : values) : values := match (v1, v2) with
// Val x1, Val x2 => Val (x1 + x2)
// | Erreur, _ => Erreur
// | _, Erreur => Erreur
// end.
symbol eval_EA : ğ”¼ğ”¸ â†’ Î£ â†’ ğ•â†’ Prop
constant symbol eval_var s x :
  Ï€ (eval_EA (var x) s (val (s x)))
constant symbol eval_nb  s n :
  Ï€ (eval_EA (ent n) s (val n))
constant symbol eval_plus s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (plus a1 a2) s (i_plus n1 n2))
// constant symbol eval {a} (s:Î£ {a}) a1 a2 n1 n2 :
//  Ï€ (eval_EA s (plus a1 a2) (i_plus  (eval_EA s a1) (eval_EA s a2)))
constant symbol eval_moins s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (moins a1 a2) s (i_moins n1 n2))
constant symbol eval_fois s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (fois a1 a2) s (i_fois n1 n2))
constant symbol eval_div s a1 a2 n1 n2 :
  Ï€ (eval_EA a1 s n1) â†’ Ï€ (eval_EA a2 s n2) â†’
  Ï€ (eval_EA (div a1 a2) s (i_div n1 n2))

symbol ent_inv s n1 n2 :
  Ï€ (eval_EA (ent n1) s (val n2)) â†’ Ï€ (n1 = n2)

//compute eval_EA (plus (ent 3) (ent 4)) _ (val (ent 7))
type plus (ent 3) (ent 4)

theorem eval_example s :
Ï€ (eval_EA (fois (ent 2) (ent 3)) s (val 6))
proof
  assume s
  apply eval_fois s (ent 2) (ent 3) (val 2) (val 3)
  // 0. Ï€ (eval_EA (ent 2) s (val 2))
  apply eval_nb s 2
  // 1. Ï€ (eval_EA (ent 3) s (val 3))
  apply eval_nb s 3
qed

theorem det_eval_EA a s v1 v2 :
Ï€ (eval_EA a s v1) â†’ Ï€ (eval_EA a s v2) â†’ Ï€ (v1 = v2)
proof
  assume a s v1 v2
  refine EA_ind (Î»a, (eval_EA a s v1 âŠƒ eval_EA a s v2 âŠƒ v1 = v2)) _ _ _ _ _ _ a
  // 0. Î n: Ï„ nat, Ï€ (eval_EA (ent n) s v1) â†’ Ï€ (eval_EA (ent n) s v2) â†’ Ï€ (v1 = v2)
  assume n Hv1 Hv2 fail // apply ent_inv
  // 1. Î x: Ï„ Vvar, Ï€ (eval_EA (var x) s v1) â†’ Ï€ (eval_EA (var x) s v2) â†’ Ï€ (v1 = v2)

  // 2. Î a1: Ï„ EA, (Ï€ (eval_EA a1 s v1) â†’ Ï€ (eval_EA a1 s v2) â†’ Ï€ (v1 = v2)) â†’ Î a2: Ï„ EA, (Ï€ (eval_EA a2 s v1) â†’ Ï€ (eval_EA a2 s v2) â†’ Ï€ (v1 = v2)) â†’ Ï€ (eval_EA (plus a1 a2) s v1) â†’ Ï€ (eval_EA (plus a1 a2) s v2) â†’ Ï€ (v1 = v2)

  // 3. Î a1: Ï„ EA, (Ï€ (eval_EA a1 s v1) â†’ Ï€ (eval_EA a1 s v2) â†’ Ï€ (v1 = v2)) â†’ Î a2: Ï„ EA, (Ï€ (eval_EA a2 s v1) â†’ Ï€ (eval_EA a2 s v2) â†’ Ï€ (v1 = v2)) â†’ Ï€ (eval_EA (moins a1 a2) s v1) â†’ Ï€ (eval_EA (moins a1 a2) s v2) â†’ Ï€ (v1 = v2)

  // 4. Î a1: Ï„ EA, (Ï€ (eval_EA a1 s v1) â†’ Ï€ (eval_EA a1 s v2) â†’ Ï€ (v1 = v2)) â†’ Î a2: Ï„ EA, (Ï€ (eval_EA a2 s v1) â†’ Ï€ (eval_EA a2 s v2) â†’ Ï€ (v1 = v2)) â†’ Ï€ (eval_EA (fois a1 a2) s v1) â†’ Ï€ (eval_EA (fois a1 a2) s v2) â†’ Ï€ (v1 = v2)

  // 5. Î a1: Ï„ EA, (Ï€ (eval_EA a1 s v1) â†’ Ï€ (eval_EA a1 s v2) â†’ Ï€ (v1 = v2)) â†’ Î a2: Ï„ EA, (Ï€ (eval_EA a2 s v1) â†’ Ï€ (eval_EA a2 s v2) â†’ Ï€ (v1 = v2)) â†’ Ï€ (eval_EA (div a1 a2) s v1) â†’ Ï€ (eval_EA (div a1 a2) s v2) â†’ Ï€ (v1 = v2)
qed
